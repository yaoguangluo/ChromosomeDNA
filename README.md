# 《ChromosomeDNA》
![](https://img.shields.io/badge/platform-windows-blue.svg)
![](https://img.shields.io/badge/platform-linux-red.svg)
![](https://img.shields.io/badge/platform-ios-black.svg)
![](https://img.shields.io/badge/platform-solaris-green.svg)
![](https://img.shields.io/badge/platform-unix-lightgrey.svg)
![](https://img.shields.io/badge/platform-android-yellow.svg)
![](https://img.shields.io/badge/platform-arm-pink.svg)
## 商业名称《华瑞集》， 工程名称 《元基花》，公司开源项目代号 《女娲计算》，作者喜欢称呼它为 《绽放的染色体》。
	1 作者的研发动机：通过设计这个生命软件， 满足工业，农业，服务业的 大数据类 智慧计算 需求。
	2 该项目涉及源码 罗瑶光先生 以 法定 完整著作权人名义 通过 《GPL2.0 标准协议》 开源。    
	
#### 核心贡献
	1 Java api https://github.com/yaoguangluo/ChromosomeDNA/blob/main/BloomChromosome_V19001_20220108.jar
	1.1 jar api 大小仅仅5兆， 其中class文件 含有完整 阅读source 对应，综合大小 仅仅14兆。 
	2 论著书籍  https://github.com/yaoguangluo/ChromosomeDNA/tree/main/元基催化与肽计算第四修订版本整理 的 V00818 编号。
	2.1 docx 论著 十七章， 35万余字， 1800页+。 上下册 总大小36兆- 。
#### 核心价值
 	1 单机联想Y7000笔记本win10 实测每秒中文分词 1650万中文字， 词库65000+，函数准确率100%，缺失语法函数 0.3%-， 算法准确率 99.7%+， 100%完整开放源码，在api与书籍中。
	2 单机联想Y7000笔记本win10 实测每秒 double高精度数组 每秒可排序1150万，准确率100% 见top sort 5代 100%完整开放源码，在api与书籍中。
	3 单机联想Y7000笔记本win10 实测每秒 精度索引 900万字+中文数据，准确率100%，100%完整开放源码，在api与书籍中。
	4 单机联想Y7000笔记本win10 实测每秒 计算 600万字+ DNN 的极速文章重心识别. 100%完整开放源码，在api与书籍中。
	5 单机联想Y7000笔记本win10 实测每秒 计算 200万+ 坐标的极速雷达边缘坐标识别. 100%完整开放源码，在api与书籍中。
	6 单机联想Y7000笔记本win10 实测每秒 象契中文拼音笔画排序 随机测试600万行+ 数据，100%完整开放源码，在api与书籍中。
	6.1 实测养疗经100字搜索 1万行 JTable表格数据，平均每行50字+ 耗时小于 0.03秒。
	6.2 实测养疗经100字混合搜索 16个JTable表格数据，平均每行50字+ 耗时小于 0.13秒。
	7 单机联想Y7000笔记本win10 每秒 100万+ 三维坐标的极速商旅TSP区间催化计算. 100%完整开放源码，在api与书籍中。
	8 单机联想Y7000笔记本win10 每秒 400万QPS+ VPCS rest HTTP缓存分发服务器，100%完整开放源码，在api与书籍中。
	9 内含 语言分析，数据卷积，ETL节点计算，PLSQL数据库ORM，VPCS服务器，数据变换，数据预测，三维坐标计算，Tinshell脚本语言，9个大数据基础领域计算源码 2000余函数，100% 完整开放源码。
	10 内含 DNA元基编码，肽计算语义公式，DNA元基解码，AOPM VECS IDUQ TXHF16进制 罗盘元基数术 完整推导论述，100%完整开放源码。
	11 内含 DNA元基催化与肽计算在 DNA互联网登陆非对称概率钥匙加密，非卷积肽腐蚀图片识别，函数新陈代谢进化索引编码优化的真实应用。100%完整开放源码。 
	12 人类史 首次 提出包含频率语义元基RNA ｛F，U｝ 硬件数字逻辑思维发散，锁存器，寄存器，触发器，PN管等。在书籍中。	
	13 人类史 首次实现了 将计算机软件执行函数 按 序列化可记忆排列 进行 规范化遗传编码。 如 Tinshell PLETL 与 元基索引花。 在api与书籍中。
	14 人类史 首次全嘌呤与变嘧啶RNA 推导与定义，开启元基费洛蒙计算领域。在书籍中。

## 著作权标识 & Refer      
	1.罗瑶光. 《德塔自然语言图灵系统 V10.6.1》. 中华人民共和国国家版权局，软著登字第3951366号. 2019.
	2.罗瑶光. 《Java数据分析算法引擎系统 V1.0.0》. 中华人民共和国国家版权局，软著登字第4584594号. 2014.
	3.罗瑶光. 《德塔ETL人工智能可视化数据流分析引擎系统 V1.0.2》. 中华人民共和国国家版权局， 软著登字第4240558号. 2019.
	4.罗瑶光. 《德塔 Socket流可编程数据库语言引擎系统 V1.0.0》. 中华人民共和国国家版权局，软著登字第4317518号. 2019.
	5.罗瑶光. 《德塔数据结构变量快速转换 V1.0》. 中华人民共和国国家版权局，软著登字第4607950号. 2019. 
	6.罗瑶光. 《数据预测引擎系统 V1.0.0》. 中华人民共和国国家版权局，软著登字第5447819号. 2020.
	7.罗瑶光，罗荣武. 《类人DNA与 神经元基于催化算子映射编码方式 V_1.2.2》. 中华人民共和国国家版权局，国作登字-2021-A-00097017. 2021.
	8.罗瑶光. 《肽展公式推导与元基编码进化计算以及它的应用发现》. 中华人民共和国国家版权局，国作登字-2021-A-00042587. 2021.
	9.罗瑶光. 《DNA催化与肽展计算和AOPM-TXH-VECS-IDUQ元基解码013026中文版本》. 中华人民共和国国家版权局，国作登字-2021-A-00042586. 2021.
	10.罗瑶光，罗荣武. 《DNA元基催化与肽计算第二卷养疗经应用研究20210305》. 中华人民共和国国家版权局，国作登字-2021-L-00103660. 2021.
	11.罗瑶光，罗荣武. 《DNA 元基催化与肽计算 第三修订版V039010912》. 中华人民共和国国家版权局，国作登字-2021-L-00268255. 2021.        
	12.罗瑶光. 《DNA元基索引ETL中文脚本编译机V0.0.2》. 中华人民共和国国家版权局，SD-2021R11L2844054. 2021. （登记号：2022SR0011067）软著登字第8965266号
	13.罗瑶光. 《TinShell插件_元基花模拟染色体组计算索引系统 V20211227》. 中华人民共和国国家版权局，SD-2021R11L3629232. 2022. （已受理）
	14.类人数据生命的DNA计算思想 Github [引用日期2020-03-05] https://github.com/yaoguangluo/Deta_Resource

## 注意
	1 注意看下工程 SETTING文件，避免乱码。作者ECLIPSE IDE 仅仅涉及 UTF8 和 GBK 2种字符集编码 。
	2 Refer的 分词 ，数据库 和 DNA编码 等的 证书都是 被经过 近6个月的 审核才下发的， 任何商业描述 借鉴切记 在先权的时间 的refer 要仔细。
	3 工程与源码部署 开发文档 都清晰的归纳在 api 对应的 docx 文件中，见其目录。

## 使用方法
	Demo真实例子 基于 https://github.com/yaoguangluo/ChromosomeDNA/blob/main/BloomChromosome_V19001_20220108.jar 使用举例。 
#### 1 直接调用模式
##### 1.1 极速微分催化排序 top5代
	//已经测试通过 联想Y7000 单机 排序每秒double 1150万峰值数组。
	private int partition(double[] array, int leftPoint, int rightPoint) {
		double x= array[leftPoint]<= array[rightPoint]? array[leftPoint]: array[rightPoint];
		int leftPointReflection= leftPoint;
		while(leftPointReflection< rightPoint){
			while(!(array[leftPointReflection]> x|| leftPointReflection++ >= rightPoint)) {}
			while(array[rightPoint--]> x) {}
			if(leftPointReflection< ++rightPoint){
				double temp= array[rightPoint];
				array[rightPoint]= array[leftPointReflection];
				array[leftPointReflection]= temp;
			}
		}
		array[leftPoint]= array[rightPoint];
		array[rightPoint]= x;
		return rightPoint;
	}
###### 1.1.1 极速中文催化分词
	//已经测试通过 联想Y7000 单机 每秒分词 1630万峰值 中文字。 
	CogsBinaryForest_AE _A= new CogsBinaryForest_AE();//获取分词引擎
	_A.IV_Mixed();
	List<String> sets= new ArrayList<>();
	sets= _A.parserMixedString("你好，世界！");//分词
	Iterator<String> iterator= sets.iterator(); //得到分词的Iterator数列
	//... ...
###### 1.1.1.1 极速中文催化分词	 繁体字混合的例子
	//已经测试通过 联想Y7000 单机
	public static void main(String[] argv) throws IOException {
		CogsBinaryForest_AE _A= new CogsBinaryForest_AE();//获取分词引擎
		_A.IV_All();//函数里面有注释，按着简体中文，繁体中文 的例子 加其他的语言扩展。切词方法要注意，源码是4字长度MAx
		List<String> sets= new ArrayList<>();
		sets= _A.parserMixedString("你好，世界！請在這輸入廣告詞優化");//带繁体字的混合分词
		Iterator<String> iterator= sets.iterator(); //得到分词的Iterator数列
		while(iterator.hasNext()) {
			System.out.println(iterator.next());
		}
	}
	
###### 1.1.2  词频 词性分析
	//已经测试通过
	public static void main(String[] argv) throws IOException {	
		List<String> list= new StaticFunctionMapA_VECS_E().frequencyReader("君不见黄河之水天上来，奔流到海不复还");
		Iterator<String> iterator= list.iterator();
		while(iterator.hasNext()) {
			System.out.println(iterator.next());
		}
	
		list= new StaticFunctionMapA_VECS_E().posReader("君不见黄河之水天上来，奔流到海不复还");
		iteraor= list.iterator();
		while(iterator.hasNext()) {
			System.out.println(iterator.next());
		}	
	} 
##### 1.2 极速象契拼音笔画排序
	//已经测试通过 联想Y7000 单机
	public static void main(String[] argv) throws IOException {
		String[] strings1D= new String[16];
		strings1D[0]= "dh罗31韵律";
		strings1D[1]= "dh罗11瑶林";
		strings1D[2]= "dh罗2瑶光";
		strings1D[3]= "dh罗4韵律";
		strings1D[2]= "dh罗2尧光";
		strings1D[3]= "dh罗4运律";
		strings1D[4]= "dh罗6瑶d林";
		strings1D[5]= "dh罗瑶0.6光";
		strings1D[6]= "dh罗瑶0.3f光";
		strings1D[7]= "dh罗瑶0.61e7光";
		strings1D[8]= "dh罗瑶0.3e61光";
		strings1D[9]= "dh罗瑶0.3e6光";
		strings1D[10]= "dh罗瑶0.6e2光";
		strings1D[11]= "dh罗瑶0.3e1光";
		strings1D[12]= "dh罗韵111.21律";
		strings1D[13]= "dh罗韵15.21律";
		strings1D[14]= "dh罗瑶g林";
		strings1D[15]= "dhv罗1.09瑶光";
		StaticFunctionMapU_VECS_C.笔画拼音排序稍后进行把传参设计下(strings1D);

		/*输出结果
		 * 
		 *
	dh罗瑶0.3e1光
	dh罗瑶0.3e6光
	dh罗瑶0.3e61光
	dh罗瑶0.3f光
	dh罗瑶0.6光
	dh罗瑶0.61e7光
	dh罗瑶0.6e2光
	dh罗瑶g林
	dh罗韵111.21律
	dh罗韵15.21律
	dh罗11瑶林
	dh罗2尧光
	dh罗31韵律
	dh罗4运律
	dh罗6瑶d林
	dhv罗1.09瑶光

		 * 
		 * */
	}

##### 1.3 启动ETL
    	//调通了下，不要使用老接口，建议写新的节点。参照已有的 image read节点即可。
    	GUISample gUISample= new GUISample();
	App app= new App();
	app.gUISample= gUISample;

	CogsBinaryForest_AE _A= new CogsBinaryForest_AE();
	_A.IV_Mixed();
	Map<String, String> pos= _A.getPosCnToCn();
	JTextPane text= new JTextPane();
	app.jTabbedpane= new DetabbedPane(0, 0, null);
	gUISample.IV_(new Object[10][10], text, app, _A, pos);
	gUISample.start();	
	gUISample.validate();

	JFrame jFrame= new JFrame();
	jFrame.add(gUISample);
	jFrame.setSize(1490, 980);
	jFrame.setVisible(true);
	
##### 1.4 VPCS 服务器见 StaticFunctionMapC_AOPM_E 文件，含有丰富的启动集 。
###### 1.4.1 DNA 加密 TOKEN
	//已经测试通过 联想Y7000 单机
	//下面这个test demo 展示了 密码-> 肽文-> 肽锁+肽密码-> 密钥,pds和pde密码 -> pds转pde验证-> pde转pds验证
	//全部封装成函数
	//罗瑶光 20210830
	public static void main(String[] argv) {
		FullDNATokenPDI pDE_RNA_FullFormular= new FullDNATokenPDI();
		pDE_RNA_FullFormular.text= "控制吸收";
		pDE_RNA_FullFormular.pdw= PdeSwapFix.textToPdw(pDE_RNA_FullFormular, pDE_RNA_FullFormular.text);
		pDE_RNA_FullFormular.code= PdeSwapFix.pdwToPdc(pDE_RNA_FullFormular);
		System.out.println("肽语: "+ pDE_RNA_FullFormular.pdw);
		System.out.println("肽锁: "+ pDE_RNA_FullFormular.lock);
		System.out.println("散列肽语:"+ pDE_RNA_FullFormular.code);
		////////////////////////////////////////////////////
		pDE_RNA_FullFormular.doKeyPress(pDE_RNA_FullFormular.code, pDE_RNA_FullFormular, false);
		System.out.println("静态肽展降元概率钥匙E: "+ pDE_RNA_FullFormular.pdedeKey);
		System.out.println("静态肽展降元概率钥匙S: "+ pDE_RNA_FullFormular.pdedsKey);
		System.out.println("静态肽展降元: "+ pDE_RNA_FullFormular.pds);
		System.out.println("静态肽展增元概率钥匙E: "+ pDE_RNA_FullFormular.pdeieKey);
		System.out.println("静态肽展增元概率钥匙S: "+ pDE_RNA_FullFormular.pdeisKey);
		System.out.println("静态肽展增元: "+ pDE_RNA_FullFormular.pde);
		//////////////////////////////////////////////////////
		pDE_RNA_FullFormular.time= "" + System.currentTimeMillis();
		pDE_RNA_FullFormular.cacheId= "ID" + Math.random() + ":" + Math.random();
		System.out.println("时间:  " + pDE_RNA_FullFormular.time);
		System.out.println("账号随机缓存字符串:  " + pDE_RNA_FullFormular.cacheId);
		/////////////////////////////////////////////////////
		pDE_RNA_FullFormular.session_key= pDE_RNA_FullFormular.pde;
		System.out.println("Session: " + pDE_RNA_FullFormular.session_key);
		System.out.println("=============================================================================");
		System.out.println("开始前序验证：");
		System.out.println("开始Session解析： " + pDE_RNA_FullFormular.session_key);
		System.out.println("开始概率钥匙解析：" + pDE_RNA_FullFormular.pdedeKey+ pDE_RNA_FullFormular.pdedsKey
				+ pDE_RNA_FullFormular.pdeieKey+ pDE_RNA_FullFormular.pdeisKey);
		/////////////////////////////////////////////////
		FullDNATokenPDI pDE_RNA_FullFormular1= new FullDNATokenPDI();
		pDE_RNA_FullFormular1.pdedeKey= pDE_RNA_FullFormular.pdedeKey.toString();
		pDE_RNA_FullFormular1.pdedsKey= pDE_RNA_FullFormular.pdedsKey.toString();
		pDE_RNA_FullFormular1.pdeieKey= pDE_RNA_FullFormular.pdeieKey.toString();
		pDE_RNA_FullFormular1.pdeisKey= pDE_RNA_FullFormular.pdeisKey.toString();
		pDE_RNA_FullFormular.doKeyUnPress(pDE_RNA_FullFormular.code, pDE_RNA_FullFormular1, true);
		System.out.println();
		System.out.println("得到原降元元基DNA序列："+ pDE_RNA_FullFormular.pds);
		System.out.println("得到新降元元基DNA序列："+ pDE_RNA_FullFormular1.pds);
		System.out.println("得到原元基DNA序列："+ pDE_RNA_FullFormular.pde);
		System.out.println("得到新元基DNA序列："+ pDE_RNA_FullFormular1.pde);
		System.out.println("验证正确？");
		System.out.println(pDE_RNA_FullFormular.pde.equals(pDE_RNA_FullFormular1.pde)? "正确": "失败");

		/////////////////////////////////////////
		System.out.println("=======================================================================");
		System.out.println("开始pde降元验证：");
		FullDNATokenPDI pDE_RNA_FullFormular2= new FullDNATokenPDI();
		pDE_RNA_FullFormular2.pdeieKey= pDE_RNA_FullFormular.pdeieKey.toString();
		pDE_RNA_FullFormular2.pdeisKey= pDE_RNA_FullFormular.pdeisKey.toString();
		pDE_RNA_FullFormular2.pdedeKey= pDE_RNA_FullFormular.pdeieKey.toString();
		pDE_RNA_FullFormular2.pdedsKey= pDE_RNA_FullFormular.pdeisKey.toString();
		System.out.println("准备计算元基DNA序列："+ pDE_RNA_FullFormular1.pde);
		String pds= PdeSwapFix.pdeToPds(pDE_RNA_FullFormular1.pde, "",  pDE_RNA_FullFormular2.pdedeKey
				,  pDE_RNA_FullFormular2.pdedsKey
				,  pDE_RNA_FullFormular2.pdeieKey
				,  pDE_RNA_FullFormular2.pdeisKey);
		System.out.println("pds");
		System.out.println("pds");
		System.out.println(pDE_RNA_FullFormular1.pds);
		System.out.println(pds);
		//////////////////////////////////////////////////////////////////
		System.out.println("开始pds增元验证：");
		FullDNATokenPDI pDE_RNA_FullFormular3= new FullDNATokenPDI();
		pDE_RNA_FullFormular3.pdeieKey= pDE_RNA_FullFormular.pdeieKey.toString();
		pDE_RNA_FullFormular3.pdeisKey= pDE_RNA_FullFormular.pdeisKey.toString();
		pDE_RNA_FullFormular3.pdedeKey= pDE_RNA_FullFormular.pdeieKey.toString();
		pDE_RNA_FullFormular3.pdedsKey= pDE_RNA_FullFormular.pdeisKey.toString();

		String pde= PdeSwapFix.pdsToPde(pDE_RNA_FullFormular1.pds, "",  pDE_RNA_FullFormular3.pdedeKey
				,  pDE_RNA_FullFormular3.pdedsKey
				,  pDE_RNA_FullFormular3.pdeieKey
				,  pDE_RNA_FullFormular3.pdeisKey);
		System.out.println("pde");
		System.out.println("pde");
		System.out.println(pDE_RNA_FullFormular1.pde);
		System.out.println(pde);
	}
	
###### 1.4.2 DNA 非对称加密 前中后序 PDS 验证示例。
	//已经测试通过 联想Y7000 单机
	@SuppressWarnings("unused")
	public static void main(String[] argv) {
		String string= "罗瑶光";
		String pdw=  StaticFunctionMapA_IDUQ_C.getPDW(string);
		String lock= StaticFunctionMapA_IDUQ_C.getLock();
		String code= StaticFunctionMapA_IDUQ_C.getCode(pdw, lock);
		FullDNATokenPDI_XCDX pDE_RNA_FullFormular= new FullDNATokenPDI_XCDX();
		pDE_RNA_FullFormular.pdw= pdw.toString();
		pDE_RNA_FullFormular.lock= lock.toString();
		pDE_RNA_FullFormular.code= code.toString();
		pDE_RNA_FullFormular= StaticFunctionMapA_IDUQ_C.doPDE(pDE_RNA_FullFormular);
		FullDNATokenPDI_XCDX pDE_RNA_FullFormularNew= StaticFunctionMapA_IDUQ_C.doPrefixPDE(pDE_RNA_FullFormular);
		FullDNATokenPDI_XCDX pDE_RNA_FullFormular2= StaticFunctionMapA_IDUQ_C.doPostfixPDE(pDE_RNA_FullFormular
				, pDE_RNA_FullFormularNew);
		FullDNATokenPDI_XCDX pDE_RNA_FullFormular3= StaticFunctionMapA_IDUQ_C.doSurffixPDE(pDE_RNA_FullFormular
				, pDE_RNA_FullFormularNew);
	}

##### 1.5 普通数据计算  函数太多 见 SEM.bloom 下 StaticClassMap 文件，有上千函数的分类索引对应地址描述如 《卷积计算集》，《坐标计算集》，《数据变换集》。
###### 1.5.1 DNN 读心术
	//测试成功了，稍后优化。
	@SuppressWarnings("unused")
	public static void main(String[] argv) throws InstantiationException, IllegalAccessException, IOException {
		String string= StableString.text1;
		String[][] string1= new StaticFunctionMapP_VECS_E().aNNTest(string);	
		String[][] string2= new StaticFunctionMapP_VECS_E().dNNTest(string);	
		String[][] string3= new StaticFunctionMapP_VECS_E().rNNTest(string);	
		String[][] string4= new StaticFunctionMapP_VECS_E().sensingTest(string);	

		String[] strings= new String[3];
		strings[0]= StableString.text1;
		strings[1]= StableString.text2;
		strings[2]= StableString.text3;
		new StaticFunctionMapP_VECS_E().educationLevelTest(strings);	
		new StaticFunctionMapP_VECS_E().literarinessLevelTest(strings);	
		new StaticFunctionMapP_VECS_E().successICATest(strings);	
	}
	
###### 1.5.1 非卷积图片识别
	//已经测试通过 联想Y7000 单机
	//需要设计采样图片数据生成。
	public static void main(String[] argv) throws IOException {
		String[] string= new String[5];
		string[0]= "C:\\Users\\Lenovo\\Desktop\\deciphering\\F_DB6.txt";
		string[1]= "C:\\Users\\Lenovo\\Desktop\\deciphering\\F_DB5.txt";
		string[2]= "C:\\Users\\Lenovo\\Desktop\\deciphering\\F_DB6_jian_17.txt";
		string[3]= "C:\\Users\\Lenovo\\Desktop\\deciphering\\F_DB6_suan_17.txt";
		string[4]= "C:\\Users\\Lenovo\\Desktop\\deciphering\\线状苔藓-结节性硬化症叶状白斑_脏数据.jpg";
		new StaticFunctionMapI_VECS_E().staticMain(string);
	}
	
##### 1.6 带精度打分搜索
	//已测试， 结果正确
	public static void main(String[] argv) throws IOException {	
		ArrayList<String> 标题= new ArrayList<String>();
		Map<String, String> 内容= new HashMap<>();
		double lookrot= 0;
		标题.add("罗瑶光");
		标题.add("罗瑶林");
		标题.add("罗韵律");
		标题.add("罗振友");
		标题.add("罗振兴");
		
		内容.put("罗瑶光","罗瑶光luoyaoguang");
		内容.put("罗瑶林","罗瑶林luoyaolin");
		内容.put("罗韵律","罗韵律luoyunlv");
		内容.put("罗振友","罗振友luozhenyou");
		内容.put("罗振兴","罗振兴luozhenxin");
		
		String searchkey= "罗瑶光";
		List<Object[]> outputList = new StaticFunctionMapQ_VECS_E().searchFromTablewithScale(searchkey, 标题, 内容, lookrot);
		Iterator<Object[]> iterator= outputList.iterator();
		while(iterator.hasNext()) {
			Object[] object= iterator.next();
			for(int i= 0; i<object.length; i++) {
				System.out.println(object[i].toString());
			}
		}
		searchkey= "罗瑶";
		outputList = new StaticFunctionMapQ_VECS_E().searchFromTablewithScale(searchkey, 标题, 内容, lookrot);
		iterator= outputList.iterator();
		while(iterator.hasNext()) {
			Object[] object= iterator.next();
			for(int i= 0; i<object.length; i++) {
				System.out.println(object[i].toString());
			}
		}
		
		searchkey= "罗振";
		outputList = new StaticFunctionMapQ_VECS_E().searchFromTablewithScale(searchkey, 标题, 内容, lookrot);
		iterator= outputList.iterator();
		while(iterator.hasNext()) {
			Object[] object= iterator.next();
			for(int i= 0; i<object.length; i++) {
				System.out.println(object[i].toString());
			}
		}
	}

#### 2 元基花调用模式 真实用例
	//已经测试通过 联想Y7000 单机
	public class App_XCDX {	
		public App app;
		public void IV_(App app) {
			this.app= app;
		}
	
	public JTextField nameFeelFilter() throws Exception {	
	//传参因子[0]= "string";//准备传参索引调用模式来记忆编码。
		//传参因子[1]= "x";
		//传参因子[2]= "y";
		//传参因子[3]= "c";
		String callFunctionKey= "CfxTextField";
		StaticRootMap.initMap();
		String[] strings= new String[1];
		Map<String, Object> output= new HashMap<>();
		Map<String, Object> inputValue= new HashMap<>(); 
	//稍后准备将staticClassMap 移到 StaticFunctionMapM_VECS_C 下， 24组相关配置全部改下。这样代码就少了，就快了。
		String[] 传参因子= StaticFunctionMapM_VECS_C.annotationMap.get(callFunctionKey).split(":");
		inputValue.put(传参因子[0], null);
		inputValue.put(传参因子[1], 0);
		inputValue.put(传参因子[2], 0);
		inputValue.put(传参因子[3], null);
		output.put("传参因子", 传参因子);
		output.put("inputValues", inputValue);	
		strings[0]= "执行 M_VECS 下 "+ callFunctionKey+ " 接口, 参数是 传参因子";
		StaticRootMap.tinShellV003(strings, output);
	//取花语计算数据	
		@SuppressWarnings("unchecked")
		Map<String, Object> map= (Map<String, Object>) output.get(callFunctionKey);
		map.get("interfaceReturn");
	//数据对接
		app.nameFeelFilter= (CfxTextField) map.get("interfaceReturn");;  
		app.nameFeelFilter.setBounds(180-50, 50, 380, 80);
		app.nameFeelFilter.setBackground(Color.white);
		app.nameFeelFilter.setText(StableTag.STRING_SPACE);
		app.nameFeelFilter.addKeyListener(app);
		return app.nameFeelFilter;
	}
##### 2.1 极速象契催化分词
##### 2.2 极速象契拼音笔画排序
##### 2.3 启动ETL
##### 2.4 VPCS 服务器                      
##### 2.5 普通数据计算，将上面的 main 对应的接口 通过   tinShellV003 接口调用即可。  如下面的实例。               
	//已经测试通过 联想Y7000 单机
	StaticRootMap.initMap();                      
	String[] strings= new String[4];                      
	strings[0]= "执行 U_VECS 下 main 接口, 参数是null";                      
	strings[1]= "执行 U_VECS 下 main 接口, 参数是null";                      
	Map<String, Object> output= new HashMap<>();                      
	String[] 传参因子= new String[2];                      
	Map<String, Object> inputValue= new HashMap<>();                       
	double[] doubles= new double[5];                      
	doubles[0]= 2.2222262;                      
	doubles[1]= 3.2226222;                      
	doubles[2]= 6.2622222;                      
	doubles[3]= 4.6226222;                      
	doubles[4]= 1.2222226;                      
	double dou= 2.22;                      
	传参因子[0]= "input";//像神一样的tin god                      
	传参因子[1]= "scale";                      
	inputValue.put(传参因子[0], doubles);                      
	inputValue.put(传参因子[1], dou);                      
	output.put("传参因子", 传参因子);                      
	output.put("inputValues", inputValue);                      
	strings[2]= "执行 U_AOPM 下 median1d 接口, 参数是 传参因子";                      
	strings[3]= "执行 U_AOPM 下 fengTong1D 接口, 参数是 过程因子";                      
	StaticRootMap.tinShellV003(strings, output);                      

##### 2.6 带精度打分搜索                       


#### 研发状态
	当前版本818版见  https://github.com/yaoguangluo/ChromosomeDNA/tree/main/元基催化与肽计算第四修订版本整理 的 V00818 编号。
	第四修订版将新增和包含 
	1 第三版所有内容 见： 国作登字-2021-L-00268255 (中华人民共和国 国家版权登记中心)    
	2 元基索引花，（准备在映射map加个传参的字符串，把 变量名也标注下 20211230）。             
	3 听语系统，tinshell 002版本  神经元计算  <DNA元基索引ETL中文脚本编译机V0.0.2><已提交 知委流水号2021R11L2844054> (中华人民共和国 国家版权登记中心)                       
	3.1 花语系统， tinshell 003版本  染色体计算 <TinShell插件_元基花模拟染色体组计算索引系统 V20211227> <已提交 知委流水号2021R11L3629232> (中华人民共和国 国家版权登记中心)       
	4 元基 DNN 早期计算2页，（费洛蒙更进研究略，元基声觉略，元基磁频略）。              
	4.1 费洛蒙计算的两页历史文件见 微信，小红书和2020年12月5日抖音 脉脉视频等媒体备份，git见 bitbucket coding gitee等lyg文件。更进研究略                           	         
		https://github.com/yaoguangluo/DNA_Chromosome_backup20210705/blob/codingbackup18801/2021/12/02/InitonPDEModel.lyg           
	5 十六元基进制 DCPE-THOS-MAXF-VIUQ 与元基计数器。              
	6 TVM 元基催化虚拟机                   
	7 DNA遗传元基花孢              
	8 元基数字电路模拟， PNP NPN 触发器设计 (如全嘌呤F 与 变嘧啶U 的 数字锁存逻辑应用) 见第三版后序： 国作登字-2021-L-00268255 (中华人民共和国 国家版权登记中心)                     
	9 十六进制的元基造字替换，（之前是十七进制）                    
	10 一些细节略。 最近申请的元基花的索引序列编码方式，准备下ppt，稍后我会设计个自动识别新增函数自动注册索引。 

罗瑶光             
             
