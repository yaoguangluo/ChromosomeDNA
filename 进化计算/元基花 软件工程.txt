元基花 软件工程

芯片发明的早期时代，程序员接触的计算源，主要由机器码，指令集组成，这种非常底层的
计算逻辑，很多时候是展示给程序员和计算机看，所以描述内容也是通过源码片段用文字来注解。

1970年之后随着C语言的发明，计算机源码的文字来注解可以在函数的变量，文件名上进行
描述。加强人类职员的可阅读性。

当人类进入了互联网时代，一个工程往往不再局限于 程序员， 计算机，客户和老板，这时
候，需要一种高效的编码方法，让产品既迅捷又通俗。文字来注解 需要有概括的分类和归纳。

目前人工智能日新月异，我给计算机源码的定义为  应具备 普遍的适用性 和 代表性，编码
思维怎么更好的被理解和可持续的优化，属于一种计算进化特征 

根据这种思维，我结合了达尔文的经典遗传学 与 DNA的重组逻辑，开始设计软件的新陈代谢
，二次新陈代谢与函数索引序列。在 元基花中有很好的体现。

在我设计元基花 组件之前，感谢 计算机语言领域已经出现了严谨的extends， implements 
，inteface这些关键字。当然我还是要感谢米尔当年说要我把函数名写长点，不然他看不懂
，有概率导致我之后每次看见那么长的名称就想用几个字母缩进的冲动。因为我自己的代码
包含大量 a1 b2 c3 d4 和 temp。

元基索引语言是不是趋势我不描述，我可以给出一些具体参数来表达。如下

养疗经     分词复杂     分词简单    准确率%    排序       搜索      体积     cpu启动-待机     内存启动-待机    qps w    registers                            

元基催化前

2018        2000WS        3000WS    97         1000W      600W      800M       50%-10%         2.6G-2.3G      10/400     500    
                （sonar lint）  （补充了很多POS语法函数）
2019        1100WS        1200WS    99.97      1100W      700W      686M       50%-10%         2.6G-2.3G      10/400     2000+        
                                          （微分催化加速）
2020        1200WS        1600WS    99.97      1150W      900W      400M       40%-10%         2.6G-2.3G      10/400     1500    

元基催化后

2021        1300ws        1650ws    99.97      1150w      900w      400M       40%-10%         2.6g-2.3g      10/400     1200     
                                                                          （减少监听函数） 
2022        1350WS        1650WS    99.97      1150W      900W      383M       40%-5%          2.6G-2.1G      10/400     1100  
              （二次新陈代谢）                                 （一次新陈代谢）   （染色体配对）  （静态单例分离）
2023        1550WS        1880WS    99.97      1150W      900W      260M       30%-2%          2.3G-1.2G      10/400     1200  



目前我一直在华瑞集染色体和元基花上做优化。每一次优化后，上面这些数据保持同步更新。


罗瑶光
